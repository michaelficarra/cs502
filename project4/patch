diff -urN /usr/src/linux/arch/x86/include/asm/unistd_32.h linux-2.6.37.6-0.5/arch/x86/include/asm/unistd_32.h
--- /usr/src/linux/arch/x86/include/asm/unistd_32.h	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/arch/x86/include/asm/unistd_32.h	2011-07-02 00:33:55.310163944 -0400
@@ -346,10 +346,13 @@
 #define __NR_fanotify_init	338
 #define __NR_fanotify_mark	339
 #define __NR_prlimit64		340
+#define __NR_mailbox_send	341
+#define __NR_mailbox_rcv	342
+#define __NR_mailbox_manage	343
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 341
+#define NR_syscalls 344
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff -urN /usr/src/linux/arch/x86/kernel/syscall_table_32.S linux-2.6.37.6-0.5/arch/x86/kernel/syscall_table_32.S
--- /usr/src/linux/arch/x86/kernel/syscall_table_32.S	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/arch/x86/kernel/syscall_table_32.S	2011-07-02 00:33:55.310163944 -0400
@@ -340,3 +340,6 @@
 	.long sys_fanotify_init
 	.long sys_fanotify_mark
 	.long sys_prlimit64		/* 340 */
+	.long sys_mailbox_send
+	.long sys_mailbox_rcv
+	.long sys_mailbox_manage
diff -urN /usr/src/linux/include/linux/mailbox.h linux-2.6.37.6-0.5/include/linux/mailbox.h
--- /usr/src/linux/include/linux/mailbox.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.37.6-0.5/include/linux/mailbox.h	2011-07-05 02:00:15.349337001 -0400
@@ -0,0 +1,64 @@
+/**
+* Adapted from CS-502 Project #3, Fall 2006
+*	originally submitted by Cliff Lindsay
+* Modified for CS-3013, A-term 2008
+*
+*/
+
+#ifndef __MAILBOX__
+#define __MAILBOX__
+
+#include <stdbool.h>
+#include <linux/types.h>
+
+#define NO_BLOCK 0
+#define BLOCK   1
+#define MAX_MSG_SIZE 128
+#define CS3013_MAILBOX_SIZE 32
+
+# define alloc_CS3013_message()    ((CS3013_message *)kmem_cache_alloc(CS3013_message_cachep, GFP_KERNEL))
+# define free_CS3013_message(msg)  kmem_cache_free(CS3013_message_cachep, (msg))
+static struct kmem_cache *CS3013_message_cachep;
+
+typedef struct CS3013_mailbox {
+	struct list_head *messages;
+	bool stopped;
+	struct semaphore *empty;
+	struct semaphore *full;
+	struct semaphore *lock;
+} CS3013_mailbox;
+
+typedef struct CS3013_message {
+	struct list_head list;
+	pid_t sender_pid;
+	char text[MAX_MSG_SIZE + 1];
+	int length;
+} CS3013_message;
+
+/**
+ * Functions for msgs
+ * 
+ * */
+int SendMsg(pid_t dest, void *msg, int len, bool block);
+int RcvMsg(pid_t *sender, void *msg, int *len, bool block);
+
+/**
+ * functions for maintaining mailboxes
+ * 
+ * */
+int ManageMailbox(bool stop, int *count);
+
+/**
+ * error codes pertaining to mailboxes
+ * 
+ * */
+#define MAILBOX_FULL	1001
+#define MAILBOX_EMPTY	1002
+#define MAILBOX_STOPPED	1003
+#define MAILBOX_INVALID	1004
+#define MSG_TOO_LONG	1005
+#define MSG_ARG_ERROR	1006
+#define MAILBOX_ERROR	1007
+
+#endif
+
Binary files /usr/src/linux/include/linux/.mailbox.h.swp and linux-2.6.37.6-0.5/include/linux/.mailbox.h.swp differ
diff -urN /usr/src/linux/include/linux/sched.h linux-2.6.37.6-0.5/include/linux/sched.h
--- /usr/src/linux/include/linux/sched.h	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/include/linux/sched.h	2011-07-02 00:33:55.318164010 -0400
@@ -1185,6 +1185,8 @@
 	perf_nr_task_contexts,
 };
 
+struct CS3013_mailbox;
+
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	void *stack;
@@ -1343,6 +1345,9 @@
 	struct files_struct *files;
 /* namespaces */
 	struct nsproxy *nsproxy;
+/* CS3013 mailbox */
+	struct CS3013_mailbox *mailbox;
+	spinlock_t mailbox_lock;
 /* signal handlers */
 	struct signal_struct *signal;
 	struct sighand_struct *sighand;
diff -urN /usr/src/linux/kernel/exit.c linux-2.6.37.6-0.5/kernel/exit.c
--- /usr/src/linux/kernel/exit.c	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/exit.c	2011-07-04 23:44:30.541337001 -0400
@@ -57,6 +57,8 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <linux/mailbox.h>
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
@@ -948,6 +950,22 @@
 		schedule();
 	}
 
+	// if a CS3013_mailbox exists
+    if(tsk->mailbox) {
+		// stop CS3013_mailbox
+		tsk->mailbox->stopped = true;
+		// TODO: sem_post "full" semaphore for each waiting reader
+		if(tsk->mailbox->messages != NULL) {
+			// TODO: free unread messages
+		}
+		// free semaphores
+		kfree(tsk->mailbox->empty);
+		kfree(tsk->mailbox->full);
+		kfree(tsk->mailbox->lock);
+		// free CS3013_mailbox structure
+        kfree(tsk->mailbox);
+    }
+
 	exit_irq_thread();
 
 	exit_signals(tsk);  /* sets PF_EXITING */
Binary files /usr/src/linux/kernel/.exit.c.swp and linux-2.6.37.6-0.5/kernel/.exit.c.swp differ
diff -urN /usr/src/linux/kernel/fork.c linux-2.6.37.6-0.5/kernel/fork.c
--- /usr/src/linux/kernel/fork.c	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/fork.c	2011-07-05 01:23:43.617337003 -0400
@@ -76,6 +76,8 @@
 
 #include <trace/events/sched.h>
 
+#include <linux/mailbox.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -216,6 +218,9 @@
 	/* do the arch specific task caches init */
 	arch_task_cache_init();
 
+	// initialize CS3013_message slab allocator
+	CS3013_message_cachep = kmem_cache_create("CS3013_message", sizeof(struct CS3013_message), 0, 0, NULL);
+
 	/*
 	 * The default maximum number of threads is set to a safe
 	 * value: the thread structures can take up at most half
@@ -1453,6 +1458,25 @@
 			init_completion(&vfork);
 		}
 
+        // assign a CS3013_mailbox
+		if(p->mm != NULL) { // unless it's a kernel thread
+			if(clone_flags & CLONE_THREAD) { // just a new thread
+				// use parent's mailbox
+				p->mailbox = current->mailbox;
+			} else {
+				// allocate a new mailbox
+				p->mailbox = (CS3013_mailbox *) kmalloc(sizeof(CS3013_mailbox), GFP_KERNEL);
+				p->mailbox->stopped = false;
+				// initialize semaphores
+				p->mailbox->empty = (struct semaphore *) kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+				sema_init(p->mailbox->empty, CS3013_MAILBOX_SIZE);
+				p->mailbox->full  = (struct semaphore *) kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+				sema_init(p->mailbox->full, 0);
+				// initialize message list
+				p->mailbox->messages = NULL;
+			}
+		}
+
 		audit_finish_fork(p);
 		tracehook_report_clone(regs, clone_flags, nr, p);
 
Binary files /usr/src/linux/kernel/.fork.c.swp and linux-2.6.37.6-0.5/kernel/.fork.c.swp differ
diff -urN /usr/src/linux/kernel/mailbox.c linux-2.6.37.6-0.5/kernel/mailbox.c
--- /usr/src/linux/kernel/mailbox.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.37.6-0.5/kernel/mailbox.c	2011-07-05 02:20:51.413337001 -0400
@@ -0,0 +1,105 @@
+/* Michael Ficarra (k@wpi.edu) */
+
+#include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/unistd.h>
+
+#include <linux/mailbox.h>
+
+// int SendMsg(pid_t dest, void *msg, int len, bool block);
+SYSCALL_DEFINE4(mailbox_send, pid_t, dest_pid, void *, usr_msg, int, len, bool, block) {
+	CS3013_message *msg;
+	int msg_length;
+	struct task_struct *dest = find_task_by_vpid(dest_pid);
+
+	if(dest == NULL || dest->mailbox == NULL) return MAILBOX_INVALID;
+	if(dest->mailbox->stopped) return MAILBOX_STOPPED;
+
+	msg_length = strnlen(usr_msg, MAX_MSG_SIZE + 1);
+	if(msg_length > MAX_MSG_SIZE) return MSG_TOO_LONG;
+
+	msg = alloc_CS3013_message();
+	if(copy_from_user(&msg->text, usr_msg, MAX_MSG_SIZE))
+		return MSG_ARG_ERROR;
+	msg->text[MAX_MSG_SIZE] = '\0';
+	msg->length = msg_length;
+	msg->sender_pid = current->pid;
+	INIT_LIST_HEAD(&msg->list);
+
+	if(block) {
+		while(down_interruptible(dest->mailbox->empty))
+			/* do nothing */;
+	} else {
+		if(down_trylock(dest->mailbox->empty))
+			return MAILBOX_FULL;
+	}
+	spin_lock(&dest->mailbox_lock);
+
+	if(dest->mailbox->stopped) {
+		up(dest->mailbox->empty);
+		spin_unlock(&dest->mailbox_lock);
+		return MAILBOX_STOPPED;
+	}
+
+	if(dest->mailbox->messages == NULL) {
+		dest->mailbox->messages = &msg->list;
+	} else {
+		list_add_tail(&msg->list, dest->mailbox->messages);
+	}
+
+	up(dest->mailbox->full);
+	spin_unlock(&dest->mailbox_lock);
+
+	return 0;
+}
+
+// int RcvMsg(pid_t *sender, void *msg, int *len, bool block);
+SYSCALL_DEFINE4(mailbox_rcv, pid_t *, sender_pid, void *, usr_msg, int *, usr_msg_len, bool, block) {
+	CS3013_message *msg;
+	bool empty;
+	struct task_struct *self = current;
+
+	if(block) {
+		while(down_interruptible(self->mailbox->full))
+			/* do nothing */;
+	} else {
+		if(down_trylock(self->mailbox->full))
+			return MAILBOX_EMPTY;
+	}
+	spin_lock(&self->mailbox_lock);
+
+	if(self->mailbox->stopped) {
+		up(self->mailbox->full);
+		spin_unlock(&self->mailbox_lock);
+		return MAILBOX_STOPPED;
+	}
+	// sanity check
+	if(self->mailbox->messages == NULL) {
+		spin_unlock(&self->mailbox_lock);
+		return MAILBOX_EMPTY;
+	}
+
+	msg = list_entry(self->mailbox->messages, struct CS3013_message, list);
+	// TODO: move copy_to_user calls outside spinlock
+	copy_to_user(&msg->text, usr_msg, MAX_MSG_SIZE + 1);
+	copy_to_user(&msg->sender_pid, sender_pid, sizeof(pid_t));
+	copy_to_user(&msg->length, usr_msg_len, sizeof(int));
+	empty = msg->list.next == &msg->list;
+	list_del(&msg->list);
+	if(empty) self->mailbox->messages = NULL;
+	free_CS3013_message(msg);
+
+	up(self->mailbox->empty);
+	spin_unlock(&self->mailbox_lock);
+
+	return 0;
+}
+
+// int ManageMailbox(bool stop, int *count);
+SYSCALL_DEFINE2(mailbox_manage, bool, stop, int *, count) {
+
+	return 0;
+}
Binary files /usr/src/linux/kernel/.mailbox.c.swp and linux-2.6.37.6-0.5/kernel/.mailbox.c.swp differ
diff -urN /usr/src/linux/kernel/Makefile linux-2.6.37.6-0.5/kernel/Makefile
--- /usr/src/linux/kernel/Makefile	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/Makefile	2011-07-03 21:35:25.553337002 -0400
@@ -10,7 +10,7 @@
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
 	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
-	    async.o range.o jump_label.o
+	    async.o range.o jump_label.o mailbox.o
 obj-y += groups.o
 
 ifdef CONFIG_FUNCTION_TRACER
